#audio.py
import socket
import subprocess
import platform
import time
import logging
import threading
import sounddevice as sd
import numpy as np
from config import app_config

target_ip = app_config.audio_ip

PORT = app_config.audio_port
CHANNELS = 2
RATE = 44100 
FORMAT = 's16le'
CHUNK_SIZE = 1024

sock , process = None , None 

INPUT = 'audio=Stereo Mix (Realtek(R) Audio)'

logging.basicConfig(level=logging.INFO, filename="logs.log", filemode="a", format="[Audio] - %(message)s")

def cleanup(sock=None, process=None):
    try:
        if process:
            try:
                process.terminate()
                process.wait(timeout=2)
            except Exception as e:
                logging.error(f"Error terminating process: {e}")
        if sock:
            try:
                sock.close()
            except Exception as e:
                logging.error(f"Error closing socket: {e}")
    finally:
        logging.info("Cleaned up audio resources.")

def get_monitor_source():
    result = subprocess.run(['pactl', 'list', 'short', 'sources'], capture_output=True, text=True)
    for line in result.stdout.strip().split('\n'):
        if '.monitor' in line:
            return line.split('\t')[1]
    raise RuntimeError("‚ùå No monitor source found.")
def mute_output():
    subprocess.run(['pactl', 'set-sink-mute', '@DEFAULT_SINK@', '1'])
def unmute_output():
    subprocess.run(['pactl', 'set-sink-mute', '@DEFAULT_SINK@', '0'])

def send_audio_linux():
    monitor = get_monitor_source()
    mute_output()
    print(f"Sending audio  {target_ip}:{PORT}")
    logging.info(f"Sending audio {target_ip}:{PORT}")

    ffmpeg_cmd = [
        'ffmpeg',
        '-f', 'pulse',
        '-i', monitor,
        '-ac', str(CHANNELS),
        '-ar', str(RATE),
        '-f', 's16le',
        '-loglevel', 'info',
        '-'
    ]
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    process = subprocess.Popen(ffmpeg_cmd, stdout=subprocess.PIPE)
    print(f"üì§ Sending audio from {monitor} (muted locally)")
    try:
        while True:
            data = process.stdout.read(CHUNK_SIZE)
            if not data:
                break
            sock.sendto(data, (target_ip, PORT))
    except KeyboardInterrupt:
        print("‚ùå Sender stopped.")
    finally:
        unmute_output()
        cleanup(sock,process)

def send_audio_windows():
    ffmpeg_cmd = [
        'ffmpeg',
        '-f', 'dshow',
        '-i', str(INPUT),  
        '-ar', str(RATE),
        '-ac' , str(CHANNELS),
        '-f', 's16le',
        '-loglevel', 'info',
        '-'
    ]

    print(f"Sending audio  {target_ip}:{PORT}")
    logging.info(f"Sending audio {target_ip}:{PORT}")
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    process = subprocess.Popen(ffmpeg_cmd, stdout=subprocess.PIPE)

    try:
        while True:
            data = process.stdout.read(CHUNK_SIZE)
            if not data:
                break
            sock.sendto(data, (target_ip, PORT))
    except KeyboardInterrupt:
        print("‚ùå Audio sending stopped.")
    finally:
        cleanup(sock,process)
def receive_audio():
    print(f"Playing Audio...")

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(("0.0.0.0", PORT))

    stream = sd.OutputStream(
        samplerate=RATE,
        channels=CHANNELS,
        dtype='int16',
        blocksize=CHUNK_SIZE
    )

    try:
        with stream:
            while True:
                data, _ = sock.recvfrom(CHUNK_SIZE * CHANNELS * 2) 
                audio_array = np.frombuffer(data, dtype='int16').reshape(-1, CHANNELS)
                stream.write(audio_array)
    except KeyboardInterrupt:
        print("‚ùå Receiver stopped.")
    finally:
        cleanup(sock)

def receive_audio_ffplay():
    print(f"üéß Receiving audio via ffplay on port {PORT}...")
    cmd = [
        'ffplay',
        '-f', FORMAT,
        '-ac', str(CHANNELS),
        '-ar', str(RATE),
        '-i', f'udp://0.0.0.0:{PORT}',
        '-autoexit'  
    ]
    try:
        subprocess.run(cmd)
    except KeyboardInterrupt:
        print("‚ùå Receiver stopped.")

def main():
    def monitor_stop():
        while True:
            if not app_config.is_running:
                cleanup()
                break
            time.sleep(1)

    threading.Thread(target=monitor_stop, daemon=True).start()

    os_type = platform.system().lower()
    if app_config.audio_mode == "Receive_Audio":
        if os_type == "linux":
            receive_audio_ffplay()
        elif os_type == "windows":
            receive_audio()
    elif app_config.audio_mode == "Share_Audio":
        if os_type == "linux":
            send_audio_linux()
        elif os_type == "windows":
            send_audio_windows()
        else:
            print(f"‚ùå Unsupported OS: {os_type}")
            logging.info("Unsupported OS")
    else:
        print("‚ùå Invalid audio_mode in config.")
        logging.info("Invalid audio_mode in config.")

if __name__ == "__main__":
    main()

#share.py
# share.py
import sys
import socket
import threading
import json
import time
import platform
import pyperclip
import subprocess
import logging 
from pynput import mouse,keyboard
from pynput.keyboard import Controller as KeyboardController, Key  
from pynput.mouse import Button, Controller
from config import app_config

win32api = None
win32clipboard = None
if platform.system().lower() == "windows":
    try:
        import win32api
        import win32clipboard
    except ImportError:
        pass  
clipboard_lock = threading.Lock()
os_type = platform.system().lower()

if os_type == "windows":
    import win32clipboard

    def get_clipboard():
        with clipboard_lock:
            try:
                win32clipboard.OpenClipboard()
                data = win32clipboard.GetClipboardData()
                win32clipboard.CloseClipboard()
                return data
            except Exception:
                win32clipboard.CloseClipboard()
                return ""

    def set_clipboard(text):
        with clipboard_lock:
            try:
                win32clipboard.OpenClipboard()
                win32clipboard.EmptyClipboard()
                win32clipboard.SetClipboardText(text)
                win32clipboard.CloseClipboard()
            except Exception:
                win32clipboard.CloseClipboard()

elif os_type == "linux":
    def get_clipboard():
        with clipboard_lock:
            try:
                return subprocess.check_output(['xclip', '-selection', 'clipboard', '-o']).decode()
            except Exception:
                return ""

    def set_clipboard(text):
        with clipboard_lock:
            try:
                p = subprocess.Popen(['xclip', '-selection', 'clipboard'], stdin=subprocess.PIPE)
                p.communicate(input=text.encode())
            except Exception:
                pass
else:
    import pyperclip

    def get_clipboard():
        with clipboard_lock:
            return pyperclip.paste()

    def set_clipboard(text):
        with clipboard_lock:
            pyperclip.copy(text)

class MouseSyncApp:
    def __init__(self):
        self.edge_transition_cooldown = False
        self.primary_port = app_config.server_primary_port
        self.secondary_port = app_config.server_secondary_port
        self.retry = 5
        self.mouse_controller = Controller()
        self.keyboard_controller = KeyboardController()
        self.keyboard_listener = None
        self.keyboard_listener_lock = threading.Lock()
        self.server_socket = None
        self.client_socket = None
        self.secondary_client_socket = None
        self.overlay = None
        self.screen_width = None
        self.screen_height = None
        self.gui_app = None
        self.last_send = None
        self.os_type = platform.system().lower()

        logging.basicConfig(level=logging.INFO, filename="logs.log", filemode="a",format ="%(levelname)s - %(message)s")

        app_config.load()
        app_config.active_device = False
        app_config.save()

        if self.os_type == "windows":
            import tkinter as tk
            self.tk = tk
            self.gui_app = self.tk.Tk()
            self.gui_app.withdraw()
            self.screen_width = self.gui_app.winfo_screenwidth()
            self.screen_height = self.gui_app.winfo_screenheight()
        elif self.os_type == "linux":
            from PyQt5.QtWidgets import QApplication, QWidget
            from PyQt5.QtCore import Qt
            self.Qt = Qt
            self.QWidget = QWidget
            self.gui_app = QApplication(sys.argv)
            screen = self.gui_app.primaryScreen().size()
            self.screen_width = screen.width()
            self.screen_height = screen.height()

    def cleanup(self):
        print("[System] Cleaning up sockets and resources...")
        logging.info("[System] Closing all sockets")
        try:
            if self.client_socket:
                self.client_socket.shutdown(socket.SHUT_RDWR)
                self.client_socket.close()
            if self.secondary_client_socket:
                self.secondary_client_socket.shutdown(socket.SHUT_RDWR)
                self.secondary_client_socket.close()
        except Exception as e:
            print(f"[Client] Error closing socket: {e}")
            logging.info(f"[Client] Error closing socket: {e}")
        try:
            if self.server_socket:
                self.server_socket.close()
        except Exception as e:
            print(f"[Server] Error closing socket: {e}")
            logging.info(f"[Server] Error closing socket: {e}")
        if self.overlay:
            self.destroy_overlay()
        app_config.is_running = False
        app_config.save()

    def create_overlay(self):
        if not app_config.active_device:
            return
        if self.os_type == "windows":
            overlay = self.tk.Toplevel(self.gui_app)
            overlay.overrideredirect(True)
            overlay.attributes("-topmost", True)
            overlay.geometry(f"{self.screen_width}x{self.screen_height}+0+0")
            overlay.attributes("-alpha", 0.01)
            overlay.configure(bg="black")
            overlay.config(cursor="none")
            overlay.lift()
            overlay.focus_force()
            overlay.update_idletasks()
            self.overlay = overlay
        elif self.os_type == "linux":
            overlay = self.QWidget()
            overlay.setWindowFlags(self.Qt.FramelessWindowHint | self.Qt.WindowStaysOnTopHint | self.Qt.Tool)
            overlay.setAttribute(self.Qt.WA_TranslucentBackground)
            overlay.setCursor(self.Qt.BlankCursor)
            overlay.setGeometry(0, 0, self.screen_width, self.screen_height)
            overlay.setWindowOpacity(0.0)
            overlay.show()
            overlay.raise_()
            self.overlay = overlay

    def destroy_overlay(self):
        if self.overlay:
            if self.os_type == "windows":
                self.overlay.destroy()
            elif self.os_type == "linux":
                self.overlay.close()
            self.overlay = None

    def monitor_mouse_edges(self,client_socket):
        margin = 2
        while app_config.is_running:
            x, y = self.mouse_controller.position
            if not app_config.active_device and not self.edge_transition_cooldown:
                if app_config.server_direction == "Right" and x >= self.screen_width - margin:
                    self.transition(True, (margin, y))
                elif app_config.server_direction == "Left" and x <= margin:
                    self.transition(True, (self.screen_width - margin, y))
                elif app_config.server_direction == "Top" and y <= margin:
                    self.transition(True, (x, self.screen_height - margin))
                elif app_config.server_direction == "Bottom" and y >= self.screen_height - margin:
                    self.transition(True, (x, margin))
            elif app_config.active_device and not self.edge_transition_cooldown:
                if app_config.server_direction == "Right" and x <= margin:
                    self.transition(False, (self.screen_width - margin, y))
                elif app_config.server_direction == "Left" and x >= self.screen_width - margin:
                    self.transition(False, (margin, y))
                elif app_config.server_direction == "Top" and y >= self.screen_height - margin:
                    self.transition(False, (x, margin))
                elif app_config.server_direction == "Bottom" and y <= margin:
                    self.transition(False, (x, self.screen_height - margin))

            # Cooldown Reset
            if margin < x < self.screen_width - margin and margin < y < self.screen_height - margin:
                self.edge_transition_cooldown = False

            time.sleep(0.01)

    def clipboard_sender(self, _socket):
        current_clip = get_clipboard()
        try:
            data = {"type": "clipboard", "content": current_clip}
            _socket.sendall((json.dumps(data) + "\n").encode())
            print("[Clipboard] Sent clipboard data")
        except Exception as e:
            print(f"[Clipboard] Error: {e}")

    def transition(self, to_active, new_position):
        app_config.load()
        app_config.active_device = to_active
        self.edge_transition_cooldown = True
        if self.os_type == "windows":
            self.gui_app.after_idle( self.create_overlay if to_active else self.destroy_overlay)
            self.mouse_controller.position = new_position  
        else:
            if to_active:
                self.create_overlay()
            else:
                self.destroy_overlay()
            
            if win32api:
                win32api.SetCursorPos(new_position)
            else: 
                self.mouse_controller.position = new_position
        
        try:
            active_msg = {"type": "active_device", "value": to_active}
            self.secondary_server.sendall((json.dumps(active_msg) + "\n").encode())
        except Exception as e:
            print(f"[Transition] Failed to send active_device state: {e}")
            logging.info(f"[Transition] Failed to send active_device state: {e}")

        if to_active:
            current_clip = get_clipboard()
            if self.last_send != current_clip:
                self.last_send = current_clip
                self.clipboard_sender(self.secondary_server)

        
        print(f"[System] Device {'Activated' if to_active else 'Deactivated'} at {new_position}")
        logging.info(f"[System] Device {'Activated' if to_active else 'Deactivated'} at {new_position}")
        app_config.save()
        time.sleep(0.2)

    def input_sender_mouse(self, client_socket):
        def send_json(data):
            try:
                client_socket.sendall((json.dumps(data) + "\n").encode())
            except Exception as e:
                app_config.is_running = False
                app_config.save()
                print(f"[Server] Send failed: {e}")
                logging.info("[Server] Send failed: {e}")
    
        def on_move(x, y):
            if not app_config.active_device and app_config.is_running:
                return
            norm_x = x / self.screen_width
            norm_y = y / self.screen_height
            send_json({"type": "move", "x": norm_x, "y": norm_y})
    
        def on_click(x, y, button, pressed):
            if not app_config.active_device:
                return
            send_json({"type": "click", "button": button.name, "pressed": pressed})
    
        def on_scroll(x, y, dx, dy):
            if not app_config.active_device:
                return
            send_json({"type": "scroll", "dx": dx, "dy": dy})

        mouse.Listener(on_move=on_move, on_click=on_click, on_scroll=on_scroll).start()

    def input_sender_keyboard(self, client_socket):
        def send_json(data):
            try:
                client_socket.sendall((json.dumps(data) + "\n").encode())
            except Exception as e:
                app_config.is_running = False
                app_config.save()
                print(f"[Server] Send failed: {e}")
                logging.info("[Server] Send failed: {e}")

        def on_press(key):
            if not app_config.active_device:
                return
            try:
                send_json({"type": "key_press", "key": key.char})
            except AttributeError:
                send_json({"type": "key_press", "key": str(key)})
    
        def on_release(key):
            if not app_config.active_device:
                return
            try:
                send_json({"type": "key_release", "key": key.char})
            except AttributeError:
                send_json({"type": "key_release", "key": str(key)})
    
        # Keyboard listener handler thread
        def keyboard_listener_watcher():
            while app_config.is_running:
                with self.keyboard_listener_lock:
                    if app_config.active_device and self.keyboard_listener is None:
                        self.keyboard_listener = keyboard.Listener(
                            on_press=on_press, on_release=on_release, suppress=True
                        )
                        self.keyboard_listener.start()
    
                    elif not app_config.active_device and self.keyboard_listener is not None:
                        self.keyboard_listener.stop()
                        self.keyboard_listener = None
                time.sleep(0.5)
    
        threading.Thread(target=keyboard_listener_watcher, daemon=True).start()
    
    def handle_primary(self, client_socket):
        threading.Thread(target=self.monitor_mouse_edges,args=(client_socket,), daemon=True).start()
        threading.Thread(target=self.input_sender_mouse, args=(client_socket,), daemon=True).start()

    def handle_secondary(self, sec_socket):        
        threading.Thread(target=self.input_sender_keyboard, args=(sec_socket,), daemon=True).start()

    def start_server(self):
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server_socket.bind(("0.0.0.0", self.primary_port))
        self.server_socket.listen(1)
        print("[Server] Waiting for Client to connect")
        logging.info("[Server] Waiting for Client to connect")

        def accept_primary():
            client, addr = self.server_socket.accept()
            client.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
            print(f"[Server] Primary connection from: {addr}")
            client.sendall(b'CONNECTED\n')
            self.handle_primary(client)

        def accept_secondary():
            def read_clipboard():
                while app_config.is_running:
                    try:
                        data = self.secondary_server.recv(1024).decode()
                        if not data:
                            break
                        else:
                            try:
                                evt = json.loads(data)
                                if evt["type"] == "clipboard":
                                    current_clipboard = evt["content"]
                                    local_clip = get_clipboard()
                                    if current_clipboard != local_clip:
                                        app_config.clipboard = current_clipboard
                                        set_clipboard(current_clipboard)
                                        app_config.save()
                                        logging.info("[Clipboard] Updated.")
                            except json.JSONDecodeError as e:
                                print(f"[Clipboard] JSON decode error: {e}")

                    except Exception as e:
                        print(f"[Clipboard] Error reading clipboard data: {e}")
            sec_socket, sec_addr = self.secondary_server_socket.accept()
            sec_socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
            print(f"[Server] Secondary connection from: {sec_addr}")
            self.secondary_server = sec_socket
            self.handle_secondary(sec_socket)
            threading.Thread(target=read_clipboard, daemon=True).start()
            logging.info("[Server] Connected Successfully")

        self.secondary_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.secondary_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.secondary_server_socket.bind(("0.0.0.0", self.secondary_port))
        self.secondary_server_socket.listen(1)
        
        threading.Thread(target=accept_primary, daemon=True).start()
        threading.Thread(target=accept_secondary, daemon=True).start()

    def start_client(self):

        self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.client_socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)

        self.secondary_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.secondary_client_socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        print(f"[Client] Connecting to {app_config.server_ip}:{self.primary_port}")

        for i in range(10,-1,-1):
            try:
                self.client_socket.connect((app_config.server_ip, self.primary_port))
                if self.client_socket.recv(1024) != b'CONNECTED\n':
                    raise Exception("Handshake failed")
                break
            except Exception as e:
                E = e
                print(f"Retrying connection (primary) Attempt: {i}")
                logging.info(f"Retrying connection (primary) Attempt: {i}")
                time.sleep(1)
        else:
            print(f"[Client] Connection failed: {E}")
            logging.info(f"[Client] Connection failed: {E}")
            app_config.is_running = False
            self.cleanup()
            app_config.save()
            return
        print("[Client] Primary Connected")

        def receive_primary():
            buffer = ""
            while app_config.is_running:
                try:
                    data = self.client_socket.recv(1024).decode()
                except Exception as e:
                    print(f"[Client] Receive error: {e}")
                    app_config.is_running = False
                    app_config.save()
                    break
                if not data:
                    break
                buffer += data
                while "\n" in buffer:
                    line, buffer = buffer.split("\n", 1)
                    try:
                        evt = json.loads(line)
                        if evt["type"] == "move":
                            x = int(evt["x"] * self.screen_width)
                            y = int(evt["y"] * self.screen_height)
                            new_position = (x,y)
                            if win32api:
                                win32api.SetCursorPos(new_position)
                            else: 
                                self.mouse_controller.position = new_position
                        elif evt["type"] == "click":
                            btn = getattr(Button, evt['button'])
                            if evt['pressed']:
                                self.mouse_controller.press(btn)
                            else:
                                self.mouse_controller.release(btn)
                        elif evt["type"] == "scroll":
                            self.mouse_controller.scroll(evt['dx'], evt['dy'])
                    except Exception as e:
                        print(f"[Client] Parse error: {e}")

        print(f"[Client] Connecting to {app_config.server_ip}:{self.secondary_port}")
        for i in range(10,-1,-1):
            try:
                self.secondary_client_socket.connect((app_config.server_ip, self.secondary_port))
                logging.info("[Client] Connected successfully.")
                print("[Client] Connected successfully.")
                break
            except Exception as e:
                E = e
                logging.info(f"Retrying connection (secondary) Attempt: {i}")
                print(f"Retrying connection (secondary) Attempt: {i}")
                time.sleep(1)
        else:
            print(f"[Client] Connection failed: {E}")
            logging.info(f"[Client] Connection failed: {E}")
            app_config.is_running = False
            self.cleanup()
            app_config.save()
            return 
        print("[Client] Secondary Connected")
                
        def receive_secondary():
            def parse_key(key_str):
                if key_str.startswith("Key."):
                    try:
                        return getattr(Key, key_str.split(".", 1)[1])
                    except AttributeError:
                        print(f"[Parse] Unknown special key: {key_str}")
                        return None
                return key_str
            buffer = ""
            while app_config.is_running:
                try:
                    data = self.secondary_client_socket.recv(1024).decode()
                except Exception as e:
                    print(f"[Client] Secondary receive error: {e}")
                    app_config.is_running = False
                    app_config.save()
                    break
                if not data:
                    break
                buffer += data
                while "\n" in buffer:
                    line, buffer = buffer.split("\n", 1)
                    try:
                        evt = json.loads(line)
                        if evt["type"] == "key_press":
                            key = parse_key(evt["key"])
                            if key:
                                self.keyboard_controller.press(key)
                        elif evt["type"] == "key_release":
                            key = parse_key(evt["key"])
                            if key:
                                self.keyboard_controller.release(key)
                        elif evt["type"] == "active_device":
                            app_config.active_device = evt["value"]
                            app_config.save()
                            if not app_config.active_device:
                                current_clip = get_clipboard()
                                if self.last_send != current_clip:
                                    self.last_send = current_clip
                                    self.clipboard_sender(self.secondary_client_socket)
                        elif evt["type"] == "clipboard":
                            current_clip = get_clipboard()
                            if current_clip != evt["content"]:
                                app_config.clipboard = evt["content"]
                                set_clipboard(evt["content"])
                                self.last_send = evt["content"]
                                app_config.save()
                                print("[Clipboard] Updated clipboard content")
                                logging.info("[Clipboard] Updated.")

                    except Exception as e:
                        print(f"[Client] Secondary parse error: {e}")

        threading.Thread(target=receive_primary, daemon=True).start()
        threading.Thread(target=receive_secondary, daemon=True).start()

    def run(self):
        app_config.is_running = True
        if app_config.mode == "server":
            self.start_server()
        else:
            self.start_client()

        def monitor_stop():
            while app_config.is_running and not app_config.stop_flag:
                time.sleep(0.5)
            self.cleanup()
            self.gui_app.quit()
        threading.Thread(target=monitor_stop, daemon=True).start()

        if self.os_type == "windows":
            self.gui_app.mainloop()
        else:
            self.gui_app.exec_()

if __name__ == "__main__":
    MouseSyncApp().run()

#portal.py
import tkinter as tk
from tkinter import ttk
from config import app_config
import threading
import subprocess
import time
import logging 
import platform
import sys,os
import socket 

if False:
    # Importing modules for building purpose
    import win32api
    import win32clipboard
    import sounddevice as sd
    import numpy as np
    from PyQt5.QtWidgets import QApplication, QWidget
    from PyQt5.QtCore import Qt
    
def get_executable(name):
    if getattr(sys, 'frozen', False):
        base = os.path.dirname(sys.executable)
        ext = ".exe" if platform.system().lower() == "windows" else ""
        return os.path.join(base, name + ext)
    else:
        return [sys.executable, name + ".py"]  

class PortalUI:
    def __init__(self, root):
        self.root = root
        self.os_type = platform.system().lower()
        self.root.title("Portal")
        self.root.withdraw() 
        icon_path = "portal.ico"
        if hasattr(sys, "_MEIPASS"):  
            icon_path = os.path.join(sys._MEIPASS, icon_path)

        if sys.platform.startswith("win") and os.path.exists(icon_path):
            self.root.iconbitmap(icon_path)
        self.root.geometry("350x550")
        self.root.deiconify()
        self.mode = tk.StringVar(value=app_config.mode)
        self.audio_enabled = tk.BooleanVar(value=app_config.audio_enabled)
        self.running = False
        self.invis_process = None
        self.audio_process = None

        self.tab_control = ttk.Notebook(root)
        self.portal_tab = ttk.Frame(self.tab_control)
        self.logs_tab = ttk.Frame(self.tab_control)
        self.tab_control.add(self.portal_tab, text='Portal')
        self.tab_control.add(self.logs_tab, text='View Logs')
        self.tab_control.pack(expand=1, fill='both')

        with open("logs.log","w") as f:
            print("")

        logging.basicConfig(level=logging.INFO, filename="logs.log", filemode="a", format="%(levelname)s - %(message)s")

        self.tab_control.bind("<<NotebookTabChanged>>", self.on_tab_changed)
        self.create_portal_tab()

        threading.Thread(target=self.check_status, daemon=True).start()

    def on_tab_changed(self, event):
        selected_tab = event.widget.tab(event.widget.index("current"))["text"]
        if selected_tab == "View Logs":
            try:
                self.audio_process = subprocess.Popen(get_executable("log_viewer"))
                self.tab_control.select(self.portal_tab)
            except Exception as e:
                logging.info(f"Failed to open log viewer: {e}")

    def create_portal_tab(self):
        mode_frame = ttk.LabelFrame(self.portal_tab, text="Mode")
        mode_frame.pack(pady=10, padx=10, fill='x')

        server_row = ttk.Frame(mode_frame)
        server_row.pack(anchor='w', padx=10, pady=2, fill='x')

        bold_font = ('TkDefaultFont', 10, 'bold')
        style = ttk.Style()
        style.configure("Bold.TRadiobutton", font=bold_font)

        server_rb = ttk.Radiobutton(server_row, text="Server", variable=self.mode, value="server", command=self.toggle_mode, style="Bold.TRadiobutton")
        server_rb.pack(side='left')

        def get_local_ip():
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            try:
                s.connect(("8.8.8.8", 80))
                ip = s.getsockname()[0]
            except Exception:
                ip = "127.0.0.1"
            finally:
                s.close()
            return ip
        device_ip = get_local_ip()
        ip_label = ttk.Label(server_row, text=f"-  ({device_ip})", font=bold_font)
        ip_label.pack(side='left', padx=10)

        self.server_direction = tk.StringVar(value="Top")
        self.server_location_label = tk.Label(mode_frame, text="Choose where the client device is located:", fg='black')
        self.server_location_label.pack(anchor='w', padx=30, pady=(5, 0))

        self.server_top_rb = ttk.Radiobutton(mode_frame, text="Top", variable=self.server_direction, value="Top")
        self.server_left_rb = ttk.Radiobutton(mode_frame, text="Left", variable=self.server_direction, value="Left")
        self.server_right_rb = ttk.Radiobutton(mode_frame, text="Right", variable=self.server_direction, value="Right")
        self.server_bottom_rb = ttk.Radiobutton(mode_frame, text="Bottom", variable=self.server_direction, value="Bottom")

        for rb in [self.server_top_rb, self.server_left_rb, self.server_right_rb, self.server_bottom_rb]:
            rb.pack(anchor='w', padx=30)

        client_rb = ttk.Radiobutton(mode_frame, text="Client", variable=self.mode, value="client", command=self.toggle_mode, style="Bold.TRadiobutton")
        client_rb.pack(anchor='w', padx=10, pady=10)

        self.client_ip_entry = ttk.Entry(mode_frame, width=35, foreground='grey')
        self.client_ip_entry.pack(anchor='w', padx=30)
        if app_config.server_ip == "":
            self.client_ip_entry.insert(0, "Enter Server IP")
        else:
            self.client_ip_entry.insert(0, app_config.server_ip)
            
        self.client_ip_entry.bind("<FocusIn>", self.clear_placeholder)
        self.client_ip_entry.bind("<FocusOut>", self.restore_placeholder)

        # Audio radios (no section label)
        self.audio_mode = tk.StringVar(value=app_config.audio_mode)
        self.audio_mode.trace_add("write", self.on_audio_mode_change)

        self.audio_disabled_rb = ttk.Checkbutton(self.portal_tab, text="Enable Audio ", variable=self.audio_enabled, command=self.toggle_audio, style="Bold.TRadiobutton")
        self.audio_disabled_rb.pack(anchor='w', padx=10, pady=(0, 5))
        self.audio_share_rb = ttk.Radiobutton(self.portal_tab, text="Share Audio", variable=self.audio_mode, value="Share_Audio")
        self.audio_receive_rb = ttk.Radiobutton(self.portal_tab, text="Receive Audio", variable=self.audio_mode, value="Receive_Audio")

        for rb in [self.audio_disabled_rb, self.audio_share_rb, self.audio_receive_rb]:
            rb.pack(anchor='w', padx=20, pady=2 )
        self.audio_share_rb.pack(padx=40)
        self.audio_receive_rb.pack(padx=40)

        control_frame = ttk.Frame(self.portal_tab)
        control_frame.pack(pady=20)

        self.status_label = ttk.Label(control_frame, text="Portal is not running", foreground="red")
        self.status_label.grid(row=0, column=0, columnspan=2, pady=5)

        self.reload_button = ttk.Button(control_frame, text="Reload", command=lambda: self.toggle_portal("reload"))
        self.reload_button.grid(row=1, column=0, padx=5)

        self.start_stop_button = ttk.Button(control_frame, text="Start", command=lambda: self.toggle_portal("start"))
        self.start_stop_button.grid(row=1, column=1, padx=5)

        self.toggle_mode()
        self.toggle_audio()

    def clear_placeholder(self, event):
        if self.client_ip_entry.get() == "Enter Server IP":
            self.client_ip_entry.delete(0, 'end')
            self.client_ip_entry.config(foreground='black')

    def restore_placeholder(self, event):
        if not self.client_ip_entry.get():
            if app_config.server_ip == "":
                self.client_ip_entry.insert(0, "Enter Server IP")
            else:
                self.client_ip_entry.insert(0, app_config.server_ip)
            self.client_ip_entry.config(foreground='grey')

    def toggle_mode(self):
        last_mode = app_config.mode
        current_mode = self.mode.get()
        is_server = current_mode == "server"
        state = 'normal' if is_server else 'disabled'

        if is_server:
            self.client_ip_entry.config(state='disabled')
            self.client_ip_entry.delete(0, 'end')
            self.client_ip_entry.insert(0, "Enter Server IP")
            self.client_ip_entry.config(foreground='grey')
        else:
            self.client_ip_entry.config(state='normal')
            self.client_ip_entry.delete(0, 'end')
            if app_config.server_ip:
                self.client_ip_entry.insert(0, app_config.server_ip)
                self.client_ip_entry.config(foreground='black')
            else:
                self.client_ip_entry.insert(0, "Enter Server IP")
                self.client_ip_entry.config(foreground='grey')

        for rb in [self.server_top_rb, self.server_left_rb, self.server_right_rb, self.server_bottom_rb]:
            rb.config(state=state)

        self.server_location_label.config(fg='black' if is_server else 'grey')

        app_config.mode = current_mode
        app_config.save()
        if last_mode != current_mode:
            logging.info(f"[System] Mode set to {current_mode}")

    def on_audio_mode_change(self, *args):
        if self.audio_mode.get() == "Share_Audio" and self.audio_enabled.get():
            self.prompt_audio_ip()

    def prompt_audio_ip(self):
        def save_ip():
            entered_ip = ip_entry.get().strip()
            if entered_ip:
                app_config.audio_ip = entered_ip
                app_config.save()
                popup.destroy()

        popup = tk.Toplevel(self.root)
        popup.title("IP")
        popup.geometry("300x120")
        tk.Label(popup, text="Enter IP of Audio Receiver:").pack(pady=10)
        ip_entry = tk.Entry(popup, width=30)
        ip_entry.insert(0, app_config.audio_ip if app_config.audio_ip else "")
        ip_entry.pack(pady=5)
        tk.Button(popup, text="Save", command=save_ip).pack(pady=5)

    def toggle_audio(self):
        state = 'normal' if self.audio_enabled.get() else 'disabled'
        self.audio_share_rb.config(state=state)
        self.audio_receive_rb.config(state=state)
        app_config.audio_enabled = self.audio_enabled.get()
        app_config.audio_mode = self.audio_mode.get()

    def toggle_portal(self, mode):
        if mode == "start" and not self.running:
            if getattr(self, 'portal_thread', None) and self.portal_thread.is_alive():
                print("Portal is already running")
                logging.info("Portal is already running.")
                return

            app_config.stop_flag = False
            self.running = True
            app_config.is_running = True
            self.status_label.config(text="Portal is running", foreground="green")
            self.start_stop_button.config(text="Stop")
            logging.info("Portal started")

            app_config.server_direction = self.server_direction.get()
            if self.client_ip_entry.get() != "Enter Server IP":
                app_config.server_ip = self.client_ip_entry.get()

            app_config.mode = self.mode.get()
            app_config.audio_enabled = self.audio_enabled.get()
            app_config.audio_mode = self.audio_mode.get()
            app_config.save()  

            
            try:
                self.invis_process = subprocess.Popen(get_executable("share"))
            except Exception as e:
                logging.info(f"Failed to launch share.py: {e}")

            if app_config.audio_enabled: 
                try:
                    self.audio_process = subprocess.Popen(get_executable("audio"))
                except Exception as e:
                    logging.info(f"Failed to launch audio.py")
            

        elif self.running and mode != "reload":
            logging.info("Stopping portal...")
            app_config.stop_flag = True
            self.running = False
            app_config.is_running = False
            self.status_label.config(text="Portal is not running", foreground="red")
            self.start_stop_button.config(text="Start")
            try:
                if self.invis_process:
                    self.invis_process.terminate()
                    self.invis_process.wait()
                self.invis_process = None
            except Exception as e:
                print(f"Failed to terminate invis.py: {e}")
            try:
                if self.audio_process:
                    self.audio_process.terminate()
                    self.audio_process.wait()
                self.audio_process = None
            except Exception as e:
                print(f"Failed to terminate audio.py: {e}")
            logging.info("Portal stopped.")

        elif self.running and mode == "reload":
            logging.info("Reloading portal...")
            self.toggle_portal("stop")
            time.sleep(0.5)
            self.toggle_portal("start")

        else:
            logging.info(f"Unknown command: {mode}")

    def check_status(self):
        while app_config.is_running and not app_config.stop_flag:
            time.sleep(0.5)
        
        self.status_label.config(text="Portal is not running", foreground="red")
        self.start_stop_button.config(text="Start")
        

if __name__ == "__main__":
    root = tk.Tk()
    app = PortalUI(root)
    root.mainloop()

#config.py
import json
import os

class AppConfig:
    def __init__(self):
        self.config_path = "config.json"
        self.set_defaults()
        self.load()

    def set_defaults(self):
        self.config = {
            # Default configuration 
            "stop_flag": False,
            "is_running": False,
            "active_device": False,
            "audio_enabled": False,
            "audio_mode": "Share_Audio",

            # Local config (specific to current instance)
            "mode": "server",  # or "client"
            "server_direction": "Right",  # screen direcion related to client
            "server_ip": "" ,
            "audio_ip":"",

            #Ports
            "server_primary_port": 50007,
            "server_secondary_port": 50008,
            "audio_port": 50009, 

            #clipboard
            "clipboard" : "" 
        }

    def load(self):
        if os.path.exists(self.config_path):
            try:
                with open(self.config_path, "r") as f:
                    data = json.load(f)
                    self.config.update(data)
            except Exception as e:
                print(f"[Config] Failed to load config: {e}")

    def save(self):
        try:
            with open(self.config_path, "w") as f:
                json.dump(self.config, f, indent=4)
        except Exception as e:
            print(f"[Config] Failed to save config: {e}")

    def __getattr__(self, name):
        return self.config.get(name)

    def __setattr__(self, name, value):
        if name in ("config_path", "config"):
            super().__setattr__(name, value)
        else:
            self.config[name] = value

app_config = AppConfig()

#log_viewer.py
# log_viewer.py
import tkinter as tk
from tkinter import ttk
import threading
import time
import os,sys

LOG_FILE = "logs.log"

def read_log(text_widget):
    last_mod_time = 0
    while True: 
        try:
            if os.path.exists(LOG_FILE):
                mod_time = os.path.getmtime(LOG_FILE)
                if mod_time != last_mod_time:
                    last_mod_time = mod_time
                    with open(LOG_FILE, "r") as f:
                        content = f.read()
                    text_widget.config(state='normal')
                    text_widget.delete('1.0', tk.END)
                    text_widget.insert(tk.END, content)
                    text_widget.config(state='disabled')
                    text_widget.see('end')
        except Exception as e:
            print(f"Error reading log file: {e}")
        time.sleep(1)

def clear_logs(text_widget):
    with open(LOG_FILE, "w") as f:
        f.truncate(0)
    text_widget.config(state='normal')
    text_widget.delete('1.0', tk.END)
    text_widget.config(state='disabled')

def main():
    root = tk.Tk()
    root.withdraw() 
    icon_path = "portal.ico"
    if hasattr(sys, "_MEIPASS"):  
        icon_path = os.path.join(sys._MEIPASS, icon_path)

    if sys.platform.startswith("win") and os.path.exists(icon_path):
        root.iconbitmap(icon_path)

    root.title("Portal Logs")
    root.geometry("600x500")
    root.deiconify() 

    text_area = tk.Text(root, state='disabled', wrap='none')
    text_area.pack(expand=True, fill='both', padx=10, pady=10)

    button_frame = ttk.Frame(root)
    button_frame.pack(pady=5)

    ttk.Button(button_frame, text="Clear Logs", command=lambda: clear_logs(text_area)).pack(side='left', padx=10)
    ttk.Button(button_frame, text="Close", command=root.destroy).pack(side='right', padx=10)

    threading.Thread(target=read_log, args=(text_area,), daemon=True).start()
    root.mainloop()

if __name__ == "__main__":
    main()

